<!--

/*
** Copyright (c) 2013 The Khronos Group Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and/or associated documentation files (the
** "Materials"), to deal in the Materials without restriction, including
** without limitation the rights to use, copy, modify, merge, publish,
** distribute, sublicense, and/or sell copies of the Materials, and to
** permit persons to whom the Materials are furnished to do so, subject to
** the following conditions:
**
** The above copyright notice and this permission notice shall be included
** in all copies or substantial portions of the Materials.
**
** THE MATERIALS ARE PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
** EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
** MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
** IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
** CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
** MATERIALS OR THE USE OR OTHER DEALINGS IN THE MATERIALS.
*/

-->

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="../../resources/js-test-style.css"/>
<script src="../../js/js-test-pre.js"></script>
<script src="../../js/webgl-test-utils.js"></script>
<title>WebGL WEBGL_compressed_texture_astc Conformance Tests</title>
<style>
img {
 border: 1px solid black;
 margin-right: 1em;
}
.testimages {
}

.testimages br {
  clear: both;
}

.testimages > div {
  float: left;
  margin: 1em;
}
</style>
</head>
<body>
<div id="description"></div>
<canvas id="canvas" width="8" height="8" style="width: 8px; height: 8px;"></canvas>
<div id="console"></div>
<script>
"use strict";
description("This test verifies the functionality of the WEBGL_compressed_texture_astc extension, if it is available.");

debug("");

var img_16x16_rgba_raw = new Uint8Array([
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff,
    0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff,
    0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff,
    0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0x0, 0xff, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
    0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff,
]);

// Compressed textures generated with ARM's ASTC encoder
// https://github.com/ARM-software/astc-encoder
var astc_4x4_argb_ldr = new Uint8Array([
    //0x13, 0xab, 0xa1, 0x5c, 0x4, 0x4, 0x1, 0x10, 0x0, 0x0, 0x10, 0x0, 0x0, 0x1, 0x0, 0x0, // HEADER
    0x42, 0x2, 0x1, 0x2, 0x2, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf,
    0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,
    0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,
    0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,
    0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,
    0x42, 0x2, 0x1, 0x2, 0x2, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x42, 0x2, 0x1, 0x2, 0x2, 0x0, 0x0, 0x0, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,
    0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,
    0x42, 0x2, 0x1, 0x2, 0x2, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0x0, 0xff,
    0x42, 0x2, 0x1, 0x2, 0x2, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0xff, 0x0,
    0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,
    0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,
    0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,
    0xfc, 0xfd, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff,
    0x42, 0x2, 0x1, 0x2, 0x2, 0x0, 0x0, 0x0, 0xf0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
]);


var wtu = WebGLTestUtils;
var contextVersion = wtu.getDefault3DContextVersion();
var canvas = document.getElementById("canvas");
var gl = wtu.create3DContext(canvas, {antialias: false});
var program = wtu.setupTexturedQuad(gl);
var extFlag = "WEBGL_compressed_texture_astc";
var ext = null;
var vao = null;
var validFormats = {

    COMPRESSED_RGBA_ASTC_4x4_KHR : 0x93B0,
    COMPRESSED_RGBA_ASTC_5x4_KHR : 0x93B1,
    COMPRESSED_RGBA_ASTC_5x5_KHR : 0x93B2,
    COMPRESSED_RGBA_ASTC_6x5_KHR : 0x93B3,
    COMPRESSED_RGBA_ASTC_6x6_KHR : 0x93B4,
    COMPRESSED_RGBA_ASTC_8x5_KHR : 0x93B5,
    COMPRESSED_RGBA_ASTC_8x6_KHR : 0x93B6,
    COMPRESSED_RGBA_ASTC_8x8_KHR : 0x93B7,
    COMPRESSED_RGBA_ASTC_10x5_KHR : 0x93B8,
    COMPRESSED_RGBA_ASTC_10x6_KHR : 0x93B9,
    COMPRESSED_RGBA_ASTC_10x8_KHR : 0x93BA,
    COMPRESSED_RGBA_ASTC_10x10_KHR : 0x93BB,
    COMPRESSED_RGBA_ASTC_12x10_KHR : 0x93BC,
    COMPRESSED_RGBA_ASTC_12x12_KHR : 0x93BD,
    COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : 0x93D0,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : 0x93D1,
    COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : 0x93D2,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : 0x93D3,
    COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : 0x93D4,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : 0x93D5,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : 0x93D6,
    COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : 0x93D7,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : 0x93D8,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : 0x93D9,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : 0x93DA,
    COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : 0x93DB,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : 0x93DC,
    COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : 0x93DD

};
var name;
var supportedFormats;

if (!gl) {
    testFailed("WebGL context does not exist");
} else {
    testPassed("WebGL context exists");

    // Run tests with extension disabled
    runTestDisabled();
    debug("");

    // Query the extension and store globally so shouldBe can access it
    ext = wtu.getExtensionWithKnownPrefixes(gl, extFlag);
    if (!ext) {
        testPassed("No WEBGL_compressed_texture_astc support -- this is legal");
        runSupportedTest(false);
    } else {
        testPassed("Successfully enabled WEBGL_compressed_texture_astc extension");

        debug("");
        runSupportedTest(true);
        runTestExtension();
    }
}

function runSupportedTest(extensionEnabled) {
    var name = wtu.getSupportedExtensionWithKnownPrefixes(gl, extFlag);
    if (name !== undefined) {
        if (extensionEnabled) {
            testPassed("WEBGL_compressed_texture_astc listed as supported and getExtension succeeded");
        } else {
            testFailed("WEBGL_compressed_texture_astc listed as supported but getExtension failed");
        }
    } else {
        if (extensionEnabled) {
            testFailed("WEBGL_compressed_texture_astc not listed as supported but getExtension succeeded");
        } else {
            testPassed("WEBGL_compressed_texture_astc not listed as supported and getExtension failed -- this is legal");
        }
    }
}


function runTestDisabled() {
    debug("Testing binding enum with extension disabled");

    supportedFormats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
    shouldBe("supportedFormats", "[]");
}

function runTestExtension() {
    debug("");
    debug("Testing " + extFlag);

    supportedFormats = gl.getParameter(gl.COMPRESSED_TEXTURE_FORMATS);
    // There should be exactly 28 formats for both WebGL 1.0 and WebGL 2.0.
    shouldBe("supportedFormats.length", "28");

    // check that all 28 formats exist
    testFormatsExist(supportedFormats);
    // check that all format enums exist.
    testCompressionFormatsValidity();
    // check that the specified restrictions fails with
    // an INVALID_VALUE error when not respected
    //testASTCFormatsRestrictions(supportedFormats);
    // Tests ASTC texture with every format
    testLDRTextures();

    // Test each format
    /*testPVRTC_RGBA_2BPP();
    testPVRTC_RGB_2BPP();
    testPVRTC_RGBA_4BPP();
    testPVRTC_RGB_4BPP();*/
}

function testFormatsExist(supportedFormats) {
    debug("");
    debug("Testing every supported formats exist");

    var failed;
    for (var name in validFormats) {
        var format = validFormats[name];
        failed = true;
        for (var ii = 0; ii < supportedFormats.length; ++ii) {
            if (format == supportedFormats[ii]) {
                testPassed("supported format " + formatToString(format) + " exists");
                failed = false;
                break;
            }
        }
        if (failed) {
            testFailed("supported format " + formatToString(format) + " does not exist");
        }
    }
}

function testCompressionFormatsValidity() {
    debug("");
    debug("Testing every supported formats is valid");

    for (name in validFormats) {
        var expected = "0x" + validFormats[name].toString(16);
        var actual = "ext['" + name + "']";
        shouldBe(actual, expected);
    }
}

/*function testASTCFormatsRestrictions() {
    for (var i = 0; i < supportedFormats.length; ++i) {

    }
}*/

/*function getTestFromFormat(format) {

    if (format === )

}*/

function testLDRTextures() {
    debug("");
    debug("Testing every LDR texture format compression");

    var tests = [];
    var testRGBA4x4 = {
        width: 16,
        height: 16,
        channels: 4,
        data: astc_4x4_argb_ldr,
        raw: null,
        format: ext.COMPRESSED_RGBA_ASTC_4x4_KHR
    };
    tests.push(testRGBA4x4);

    testASTCTextures(tests);
}

function testASTCTextures(tests) {
    debug("<hr/>");
    for (var i = 0; i < tests.length; ++i) {
        testASTCTexture(tests[i]);
    }
}

function testASTCTexture(test) {
    var data = test.data;
    var width = test.width;
    var height = test.height;
    var format = test.format;
    //var uncompressedData = test.raw;

    canvas.width = width;
    canvas.height = height;
    gl.viewport(0, 0, width, height);
    debug("testing " + formatToString(format) + " " + width + "x" + height);

    // Texture upload
    var tex = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, tex);
    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    //gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.compressedTexImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, data);
    wtu.glErrorShouldBe(gl, gl.NO_ERROR, "uploading compressed texture");

    wtu.clearAndDrawUnitQuad(gl);

    gl.compressedTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, data);
    wtu.glErrorShouldBe(gl, gl.NO_ERROR, "compressedTexSubImage2D allowed for reloading of complete textures");

    // Mipmaps handling
    /*gl.generateMipmap(gl.TEXTURE_2D);
    wtu.glErrorShouldBe(gl, gl.INVALID_OPERATION, "trying to generate mipmaps from compressed texture");

    gl.compressedTexImage2D(gl.TEXTURE_2D, 0, format, width, height, 1, data);
    wtu.glErrorShouldBe(gl, gl.INVALID_VALUE, "non 0 border");

    var byteLenError1 = checkByteLength(0, height, format, data.length);
    var byteLenError2 = checkByteLength(width, 0, format, data.length);
    var byteLenError3 = checkByteLength(0, 0, format, data.length);

    gl.compressedTexImage2D(gl.TEXTURE_2D, 0, format, 0, height, 0, data);
    wtu.glErrorShouldBe(gl, gl.INVALID_VALUE, "invalid byte length: expected " + byteLenError1 + " was " + data.length);
    gl.compressedTexImage2D(gl.TEXTURE_2D, 0, format, width, 0, 0, data);
    wtu.glErrorShouldBe(gl, gl.INVALID_VALUE, "invalid byte length: expected " + byteLenError2 + " was " + data.length);
    gl.compressedTexImage2D(gl.TEXTURE_2D, 0, format, 0, 0, 0, data);
    wtu.glErrorShouldBe(gl, gl.INVALID_VALUE, "invalid byte length: expected " + byteLenError3 + " was " + data.length);*/
    //compareRect(width, height, test.channels, width, height, uncompressedData, data, format, undefined, "NEAREST");
    // Test again with linear filtering.
    /*gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    wtu.clearAndDrawUnitQuad(gl);
    compareRect(width, height, test.channels, width, height, uncompressedData, data, format, undefined, "LINEAR");*/

    /*gl.compressedTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, format, data);
    wtu.glErrorShouldBe(gl, gl.NO_ERROR, "compressedTexSubImage2D allowed for reloading of complete textures");

    gl.compressedTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width - 2, height, format, data);
    wtu.glErrorShouldBe(gl, gl.INVALID_OPERATION, "compressedTexSubImage2D not allowed for partial texture updates");
    gl.compressedTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height - 2, format, data);
    wtu.glErrorShouldBe(gl, gl.INVALID_OPERATION, "compressedTexSubImage2D not allowed for partial texture updates");
    gl.compressedTexSubImage2D(gl.TEXTURE_2D, 0, 2, 0, width - 2, height, format, data);
    wtu.glErrorShouldBe(gl, gl.INVALID_OPERATION, "compressedTexSubImage2D not allowed for partial texture updates");
    gl.compressedTexSubImage2D(gl.TEXTURE_2D, 0, 0, 2, width, height - 2, format, data);
    wtu.glErrorShouldBe(gl, gl.INVALID_OPERATION, "compressedTexSubImage2D not allowed for partial texture updates");*/
}

function formatToString(format) {
    for (var p in ext) {
        if (ext[p] == format) {
            return p;
        }
    }
    return "0x" + format.toString(16);
}

function checkByteLength(w, h, format, dataLength) {

    if (format == ext.COMPRESSED_RGBA_ASTC_4x4_KHR)
        return Math.floor((w + 3) / 4) * Math.floor((h + 3) / 4) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_5x4_KHR)
        return Math.floor((w + 4) / 5) * Math.floor((h + 3) / 4) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_5x5_KHR)
        return Math.floor((w + 4) / 5) * Math.floor((h + 4) / 5) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_6x5_KHR)
        return Math.floor((w + 5) / 6) * Math.floor((h + 4) / 5) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_6x6_KHR)
        return Math.floor((w + 5) / 6) * Math.floor((h + 5) / 6) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_8x5_KHR)
        return Math.floor((w + 7) / 8) * Math.floor((h + 4) / 5) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_8x6_KHR)
        return Math.floor((w + 7) / 8) * Math.floor((h + 5) / 6) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_8x8_KHR)
        return Math.floor((w + 7) / 8) * Math.floor((h + 7) / 8) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_10x5_KHR)
        return Math.floor((w + 9) / 10) * Math.floor((h + 4) / 5) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_10x6_KHR)
        return Math.floor((w + 9) / 10) * Math.floor((h + 5) / 6) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_10x8_KHR)
        return Math.floor((w + 9) / 10) * Math.floor((h + 7) / 8) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_10x10_KHR)
        return Math.floor((w + 9) / 10) * Math.floor((h + 9) / 10) * 16;
    else if (format == ext.COMPRESSED_RGBA_ASTC_12x10_KHR)
        return floor((w + 11) / 12) * Math.floor((h + 9) / 10) * 16;

    //else if (format == ext.COMPRESSED_RGBA_ASTC_12x12_KHR)
    return Math.floor((w + 11) / 12) * Math.floor((h + 11) / 12) * 16;
}

/*function testPVRTC_RGBA_2BPP() {
    var tests = [
        {   width: 4,
            height: 4,
            channels: 4,
            data: pvrtc_4x4_2bpp,
            raw: pvrtc_4x4_rgba_decoded,
            format: ext.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
        }
    ];
    testPVRTCTextures(tests);
}

function testPVRTC_RGB_2BPP() {
    var tests = [
        {   width: 4,
            height: 4,
            channels: 4,
            data: pvrtc_4x4_2bpp,
            raw: pvrtc_4x4_rgb_decoded,
            format: ext.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
        }
    ];
    testPVRTCTextures(tests);
}

function testPVRTC_RGBA_4BPP() {
    var tests = [
        {   width: 4,
            height: 4,
            channels: 4,
            data: pvrtc_4x4_4bpp,
            raw: pvrtc_4x4_rgba_decoded,
            format: ext.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        }
    ];
    testPVRTCTextures(tests);
}

function testPVRTC_RGB_4BPP() {
    var tests = [
        {   width: 4,
            height: 4,
            channels: 4,
            data: pvrtc_4x4_4bpp,
            raw: pvrtc_4x4_rgb_decoded,
            format: ext.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
        }
    ];
    testPVRTCTextures(tests);
}

function testPVRTCTextures(tests) {
    debug("<hr/>");
    for (var ii = 0; ii < tests.length; ++ii) {
        testPVRTCTexture(tests[ii]);
    }
}

function insertImg(element, caption, img) {
    var div = document.createElement("div");
    div.appendChild(img);
    var label = document.createElement("div");
    label.appendChild(document.createTextNode(caption));
    div.appendChild(label);
    element.appendChild(div);
}

function makeImage(imageWidth, imageHeight, dataWidth, data, alpha) {
    var scale = 8;
    var c = document.createElement("canvas");
    c.width = imageWidth * scale;
    c.height = imageHeight * scale;
    var ctx = c.getContext("2d");
    for (var yy = 0; yy < imageHeight; ++yy) {
        for (var xx = 0; xx < imageWidth; ++xx) {
            var offset = (yy * dataWidth + xx) * 4;
            ctx.fillStyle = "rgba(" +
                    data[offset + 0] + "," +
                    data[offset + 1] + "," +
                    data[offset + 2] + "," +
                    (alpha ? data[offset + 3] / 255 : 1) + ")";
            ctx.fillRect(xx * scale, yy * scale, scale, scale);
        }
    }
    return wtu.makeImageFromCanvas(c);
}

function compareRect(
        actualWidth, actualHeight, actualChannels,
        dataWidth, dataHeight, expectedData,
        testData, testFormat, tolerance, filteringMode) {
    if(typeof(tolerance) == 'undefined') { tolerance = 5; }
    var actual = new Uint8Array(actualWidth * actualHeight * 4);
    gl.readPixels(
            0, 0, actualWidth, actualHeight, gl.RGBA, gl.UNSIGNED_BYTE, actual);

    var div = document.createElement("div");
    div.className = "testimages";
    insertImg(div, "expected", makeImage(
            actualWidth, actualHeight, dataWidth, expectedData,
            actualChannels == 4));
    insertImg(div, "actual", makeImage(
            actualWidth, actualHeight, actualWidth, actual,
            actualChannels == 4));
    div.appendChild(document.createElement('br'));
    document.getElementById("console").appendChild(div);

    var failed = false;
    for (var yy = 0; yy < actualHeight; ++yy) {
        for (var xx = 0; xx < actualWidth; ++xx) {
            var actualOffset = (yy * actualWidth + xx) * 4;
            var expectedOffset = (yy * dataWidth + xx) * 4;
            var expected = [
                    expectedData[expectedOffset + 0],
                    expectedData[expectedOffset + 1],
                    expectedData[expectedOffset + 2],
                    (actualChannels == 3 ? 255 : expectedData[expectedOffset + 3])
            ];
            for (var jj = 0; jj < 4; ++jj) {
                if (Math.abs(actual[actualOffset + jj] - expected[jj]) > tolerance) {
                    failed = true;
                    var was = actual[actualOffset + 0].toString();
                    for (var j = 1; j < 4; ++j) {
                        was += "," + actual[actualOffset + j];
                    }
                    testFailed('at (' + xx + ', ' + yy +
                                         ') expected: ' + expected + ' was ' + was);
                }
            }
        }
    }
    if (!failed) {
        testPassed("texture rendered correctly with " + filteringMode + " filtering");
    }
}*/

debug("");
var successfullyParsed = true;
</script>
<script src="../../js/js-test-post.js"></script>

</body>
</html>
